<!DOCTYPE HTML>
<html>
<head>
  <title>Proyecciones 3D Interactivas en WebGL 2.0</title>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }
    #content {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      max-width: 900px;
      margin: 0 auto;
    }
    #tools {
      background-color: #f0f8ff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: #45a049;
    }
    #info-panel {
      margin-top: 15px;
      padding: 10px;
      background-color: #e6f7ff;
      border-radius: 5px;
      font-size: 14px;
    }
    .proj-info {
      display: none;
    }
  </style>
</head>
<body>
  <div id="content">
    <h2 id="headline">Demostración Interactiva de Proyecciones 3D</h2>
    <noscript><p><b>Esta página requiere JavaScript para funcionar correctamente.</b></p></noscript>
    
    <div id="tools">
      <h3>Seleccione el tipo de proyección:</h3>
      <div id="opciones">
        <input type="radio" id="opcion1" name="proyeccion" value="perspectiva" checked>
        <label for="opcion1">Perspectiva (gluPerspective)</label><br>
        
        <input type="radio" id="opcion2" name="proyeccion" value="frustum">
        <label for="opcion2">Perspectiva Frustum (glFrustum)</label><br>
        
        <input type="radio" id="opcion3" name="proyeccion" value="ortografica">
        <label for="opcion3">Proyección Paralela (glOrtho)</label>
      </div>
      
      <div id="controls">
        <p>
          <button id="reset">Reiniciar Vista</button>
          <button id="toggleAxes">Mostrar/Ocultar Ejes</button>
        </p>
      </div>
      
      <div id="info-panel">
        <div id="perspectiva-info" class="proj-info">
          <strong>Proyección en Perspectiva (gluPerspective):</strong><br>
          - Simula cómo el ojo humano percibe la profundidad<br>
          - Los objetos más lejanos aparecen más pequeños<br>
          - Tiene un punto de fuga (convergencia de líneas)
        </div>
        <div id="frustum-info" class="proj-info">
          <strong>Proyección Frustum (glFrustum):</strong><br>
          - Variante de perspectiva con planos de recorte asimétricos<br>
          - Útil para efectos especiales o visualizaciones no estándar<br>
          - Conserva la convergencia de líneas como perspectiva normal
        </div>
        <div id="ortografica-info" class="proj-info">
          <strong>Proyección Paralela (glOrtho):</strong><br>
          - Mantiene el tamaño real de los objetos sin importar la distancia<br>
          - No hay puntos de fuga (líneas paralelas permanecen paralelas)<br>
          - Usada en dibujo técnico, planos arquitectónicos y CAD
        </div>
      </div>
    </div>
    
    <div id="canvas-holder">
      <canvas id="webglcanvas" width="800" height="500"></canvas>
    </div>
  </div>

  <!-- Shaders -->
  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec4 aColores;
    out vec4 vColores;
    void main() {
      vColores = aColores;  
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    in vec4 vColores;
    out vec4 color;
    void main() {
      color = vColores;
    }
  </script>

  <script>
    "use strict";

    var showAxes = true;
    var zoom = -15; // Valor inicial (negativo porque en OpenGL/WebGL el eje Z negativo es "adelante")
    var zoomSensitivity = 0.5; // Sensibilidad del zoom
    /* Variables globales */
    var canvas, gl;
    var cubo, piso, ejes;
    var arcBall;
    var showAxes = true;
    var monitor;

    /* Tamaño de la ventana */
    var ancho = 800;
    var alto = 500;

    /* Configuración de la escena */
    var GRADOS = 360/6;
    var cubosCount = 6;

    /* Variables Uniformes */
    var programaID;
    var uMatrizModelo, uMatrizVista, uMatrizProyeccion;

    /* Matrices */
    var MatrizModelo = new Array(16);
    var MatrizVista = new Array(16);
    var MatrizProyeccion = new Array(16);
    var Matriz = new Array(16);
    var MatrizRotacion = new Array(16);
    var B = new Array(16);

    /* Interacción */
    var boton_izq_presionado = false;

    function compilaEnlazaLosShaders() {

          /* Se compila el shader de vertice */
          var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
          gl.compileShader(shaderDeVertice);
          if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
             console.error(gl.getShaderInfoLog(shaderDeVertice));
          }

          /* Se compila el shader de fragmento */
          var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
          gl.compileShader(shaderDeFragmento);
          if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
             console.error(gl.getShaderInfoLog(shaderDeFragmento));
          }

          /* Se enlaza ambos shader */
          programaID = gl.createProgram();
          gl.attachShader(programaID, shaderDeVertice); 
          gl.attachShader(programaID, shaderDeFragmento);
          gl.linkProgram(programaID);
          if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
             console.error(gl.getProgramInfoLog(programaID));
          }

          /* Se instala el programa de shaders para utilizarlo */
          gl.useProgram(programaID);
        }

    /***************************************************************************/
    /* Funciones de Matrices y Transformaciones                                */
    /***************************************************************************/

    function toRadians(grados) {
      return grados * Math.PI / 180;
    }

    function identidad(r) {
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function traslacion(matriz, tx, ty, tz) {
      var r = new Array(16);
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = tx;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = ty;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function escalacion(matriz, sx, sy, sz) { 
      var r = new Array(16);
      r[0] = sx; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = sy; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = sz; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function rotacionX(matriz, theta) {
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = c; r[9] = -s; r[13] = 0;
      r[2] = 0; r[6] = s; r[10] = c; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r); 
    }

    function rotacionY(matriz, theta) {
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] = c; r[4] = 0; r[8] = s; r[12] = 0;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
      r[2] = -s; r[6] = 0; r[10] = c; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function rotacionZ(matriz, theta) {
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] = c; r[4] = -s; r[8] = 0; r[12] = 0;
      r[1] = s; r[5] = c; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    function ortho(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2/(der-izq); r[4] = 0; r[8] = 0; r[12] = -(der+izq)/(der-izq);
      r[1] = 0; r[5] = 2/(arr-abj); r[9] = 0; r[13] = -(arr+abj)/(arr-abj);
      r[2] = 0; r[6] = 0; r[10] = -2/(lejos-cerca); r[14] = -(lejos+cerca)/(lejos-cerca);
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    function frustum(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2*cerca/(der-izq); r[4] = 0; r[8] = (der+izq)/(der-izq); r[12] = 0;
      r[1] = 0; r[5] = 2*cerca/(arr-abj); r[9] = (arr+abj)/(arr-abj); r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = -(lejos+cerca)/(lejos-cerca); r[14] = -2*lejos*cerca/(lejos-cerca);
      r[3] = 0; r[7] = 0; r[11] = -1; r[15] = 0;
    }

    function perspective(r, fovy, aspecto, cerca, lejos) {
      var ang = fovy * 0.5;
      var f = 1.0 / Math.tan(toRadians(ang));
      r[0] = f/aspecto; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = f; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = -(lejos+cerca)/(lejos-cerca); r[14] = -2*lejos*cerca/(lejos-cerca);
      r[3] = 0; r[7] = 0; r[11] = -1; r[15] = 0;
    }

    function multiplica(c, a, b) {
      let r = new Array(16);
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          let s = 0;
          for (let k = 0; k < 4; k++)
            s += a[i + k*4] * b[k + j*4];
          r[i + j*4] = s;
        }
      }
      for (let i = 0; i < 16; i++)
        c[i] = r[i];
    }

    function lookAt(r, vistaX, vistaY, vistaZ, centroX, centroY, centroZ, arribaX, arribaY, arribaZ) {
      var vista = new Vector3(vistaX, vistaY, vistaZ);
      var centro = new Vector3(centroX, centroY, centroZ);
      var arriba = new Vector3(arribaX, arribaY, arribaZ);
      
      var n = vista.menos(centro);
      n.normaliza();
      
      var u = arriba.producto_vectorial(n);
      u.normaliza();
      
      var v = n.producto_vectorial(u);
      
      r[0] = u.x; r[4] = u.y; r[8] = u.z; r[12] = -(vistaX*u.x + vistaY*u.y + vistaZ*u.z); 
      r[1] = v.x; r[5] = v.y; r[9] = v.z; r[13] = -(vistaX*v.x + vistaY*v.y + vistaZ*v.z);
      r[2] = n.x; r[6] = n.y; r[10] = n.z; r[14] = -(vistaX*n.x + vistaY*n.y + vistaZ*n.z);
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    /***************************************************************************/
    /* Clase Vector3                                                           */
    /***************************************************************************/

    class Vector3 {
      constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
      }

      mas(v2) {
        return new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z);
      }

      menos(v2) {
        return new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z);
      }

      producto_vectorial(v2) {
        return new Vector3(
          this.y * v2.z - this.z * v2.y,
          this.z * v2.x - this.x * v2.z,
          this.x * v2.y - this.y * v2.x
        );
      }

      producto_escalar(v2) {
        return this.x * v2.x + this.y * v2.y + this.z * v2.z;
      }

      longitud() {
        return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
      }

      normaliza() {
        const l = this.longitud();
        if (l > 0) {
          this.x /= l;
          this.y /= l;
          this.z /= l;
        }
      }

      normal(v1, v2, v3) {
        const u = v2.menos(v1);
        const v = v3.menos(v1);
        const n = u.producto_vectorial(v);
        n.normaliza();
        return n;
      }

      toString() {
        return `Vector3 [x=${this.x}, y=${this.y}, z=${this.z}]`;
      }
    }

    /***************************************************************************/
    /* ArcBall: Control de rotación 3D                                         */
    /***************************************************************************/

    class ArcBall {
      constructor(w, h) {
        this.Epsilon = 1.0e-5;
        this.U = new Vector3();
        this.V = new Vector3();
        this.ajusta(w, h);
      }

      ajusta(w, h) {
        if (w <= 1.0 || h <= 1.0) return;
        this.ajustaAncho = 2.0 / (w - 1.0);
        this.ajustaAlto = 2.0 / (h - 1.0);
      }

      obtieneVector(vector, x, y) {
        let tempX = (x * this.ajustaAncho) - 1.0;
        let tempY = 1.0 - (y * this.ajustaAlto);
        let longitud2 = tempX*tempX + tempY*tempY;
        
        if (longitud2 > 1.0) {
          let norma = 1.0 / Math.sqrt(longitud2);
          vector.x = tempX * norma;
          vector.y = tempY * norma;
          vector.z = 0.0;
        } else {
          vector.x = tempX;
          vector.y = tempY;
          vector.z = Math.sqrt(1.0 - longitud2);
        }
      }

      primerPunto(x, y) {
        this.obtieneVector(this.U, x, y);
      }

      segundoPunto(x, y) {
        let q = new Cuaternion();
        this.obtieneVector(this.V, x, y);
        
        let Normal = this.U.producto_vectorial(this.V);
        if (Normal.longitud() > this.Epsilon) {
          q.x = Normal.x;
          q.y = Normal.y;
          q.z = Normal.z;
          q.w = this.U.producto_escalar(this.V);
        } else {
          q.x = q.y = q.z = q.w = 0.0;
        }
        return q;
      }
    }

    /***************************************************************************/
    /* Clase Cuaternion                                                        */
    /***************************************************************************/

    class Cuaternion {
      constructor(w = 0, x = 0, y = 0, z = 0) {
        this.w = w;
        this.x = x;
        this.y = y;
        this.z = z;
      }

      inicializa(w, v) {
        this.w = w;
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
      }

      norma2() {
        return this.w*this.w + this.x*this.x + this.y*this.y + this.z*this.z;
      }

      conjugado() {
        return new Cuaternion(this.w, -this.x, -this.y, -this.z);
      }

      static multiplica(a, b) {
        return new Cuaternion(
          a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
          a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
          a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
          a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
        );
      }

      static multiplica_escalar(a, b) {
        return new Cuaternion(a.w*b, a.x*b, a.y*b, a.z*b);
      }

      inverso() {
        let n = this.norma2();
        if (n <= 1e-8) return null;
        return Cuaternion.multiplica_escalar(this.conjugado(), 1/n);
      }

      static rota2(a, q) {
        let d = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;
        let s = (d > 0.0) ? (2.0 / d) : 0.0;
        
        a[0] = 1.0 - (q.y*q.y + q.z*q.z)*s;
        a[1] = (q.x*q.y + q.w*q.z)*s;
        a[2] = (q.x*q.z - q.w*q.y)*s;
        a[3] = 0;
        
        a[4] = (q.x*q.y - q.w*q.z)*s;
        a[5] = 1.0 - (q.x*q.x + q.z*q.z)*s;
        a[6] = (q.y*q.z + q.w*q.x)*s;
        a[7] = 0;
        
        a[8] = (q.x*q.z + q.w*q.y)*s;
        a[9] = (q.y*q.z - q.w*q.x)*s;
        a[10] = 1.0 - (q.x*q.x + q.y*q.y)*s;
        a[11] = 0;
        
        a[12] = 0;
        a[13] = 0;
        a[14] = 0;
        a[15] = 1;
      }

      toString() {
        return `Cuaternion [w=${this.w}, x=${this.x}, y=${this.y}, z=${this.z}]`;
      }
    }

    /***************************************************************************/
    /* Clases para los objetos 3D                                              */
    /***************************************************************************/

    class Piso {
      constructor(gl, r, g, b) {
        let vertices = [];
        let colores = [];
        
        // Crear líneas de la cuadrícula
        for (let x = -10; x <= 10; x++) {
          vertices.push(x, -1, 10, x, -1, -10);
          colores.push(r, g, b, 1, r, g, b, 1);
        }
        for (let z = 10; z >= -10; z--) {
          vertices.push(-10, -1, z, 10, -1, z);
          colores.push(r, g, b, 1, r, g, b, 1);
        }
        
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);
        
        let verticeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        
        let colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
        
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
        this.vertexCount = vertices.length / 3;
      }

      dibuja(gl) {
        gl.bindVertexArray(this.vao);
        gl.drawArrays(gl.LINES, 0, this.vertexCount);
        gl.bindVertexArray(null);
      }
    }

    class Cubo {
      constructor(gl) {
        // Coordenadas de los vértices (8 vértices, cada uno con x,y,z)
        let vertices = [
          // Frente
          -1, -1, 1,  1, -1, 1,  1, 1, 1,  -1, 1, 1,
          // Atrás
          -1, 1, -1,  1, 1, -1,  1, -1, -1,  -1, -1, -1,
          // Izquierda
          -1, -1, -1,  -1, -1, 1,  -1, 1, 1,  -1, 1, -1,
          // Derecha
          1, -1, 1,  1, -1, -1,  1, 1, -1,  1, 1, 1,
          // Abajo
          -1, -1, -1,  1, -1, -1,  1, -1, 1,  -1, -1, 1,
          // Arriba
          -1, 1, 1,  1, 1, 1,  1, 1, -1,  -1, 1, -1
        ];
        
        // Colores para cada vértice (RGBA)
        let colores = [
          // Frente (magenta)
          1, 0, 1, 1,  1, 0, 1, 1,  1, 0, 1, 1,  1, 0, 1, 1,
          // Atrás (amarillo)
          1, 1, 0, 1,  1, 1, 0, 1,  1, 1, 0, 1,  1, 1, 0, 1,
          // Izquierda (cyan)
          0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,
          // Derecha (rojo)
          1, 0, 0, 1,  1, 0, 0, 1,  1, 0, 0, 1,  1, 0, 0, 1,
          // Abajo (azul)
          0, 0, 1, 1,  0, 0, 1, 1,  0, 0, 1, 1,  0, 0, 1, 1,
          // Arriba (verde)
          0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1
        ];
        
        // Índices para dibujar los triángulos
        let indices = [
          0, 1, 2,  0, 2, 3,    // Frente
          4, 5, 6,  4, 6, 7,    // Atrás
          8, 9, 10, 8, 10,11,   // Izquierda
          12,13,14, 12,14,15,   // Derecha
          16,17,18, 16,18,19,   // Abajo
          20,21,22, 20,22,23    // Arriba
        ];
        
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);
        
        // Buffers de vértices
        let verticeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        
        // Buffers de colores
        let colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
        
        // Buffer de índices
        let indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        
        this.indexCount = indices.length;
      }

      dibuja(gl) {
        gl.bindVertexArray(this.vao);
        gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }

    class Ejes {
      constructor(gl) {
        // Ejes X (rojo), Y (verde), Z (azul)
        let vertices = [
          0, 0, 0,  5, 0, 0,  // Eje X
          0, 0, 0,  0, 5, 0,  // Eje Y
          0, 0, 0,  0, 0, 5   // Eje Z
        ];
        
        let colores = [
          1, 0, 0, 1,  1, 0, 0, 1,  // Rojo
          0, 1, 0, 1,  0, 1, 0, 1,  // Verde
          0, 0, 1, 1,  0, 0, 1, 1   // Azul
        ];
        
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);
        
        let verticeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        
        let colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
        
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        
        this.vertexCount = vertices.length / 3;
      }

      dibuja(gl) {
        gl.bindVertexArray(this.vao);
        gl.drawArrays(gl.LINES, 0, this.vertexCount);
        gl.bindVertexArray(null);
      }
    }

            class MonitorPlano {
  constructor(gl) {
    // Dimensiones realistas para un monitor 16:9 (ancho, alto, grosor)
    const ancho = 1.6;
    const alto = 0.9;
    const grosor = 0.05;
    const grosorMarco = 0.02;
    
    // 24 vértices (6 caras x 4 vértices) como en el cubo original
    var vertices = [
      // Pantalla frontal (con marco)
      // Esquina inferior izquierda (marco)
      -ancho/2, -alto/2, grosor/2,
      // Esquina inferior derecha (marco)
      ancho/2, -alto/2, grosor/2,
      // Esquina superior derecha (marco)
      ancho/2, alto/2, grosor/2,
      // Esquina superior izquierda (marco)
      -ancho/2, alto/2, grosor/2,
      
      // Parte trasera
      -ancho/2, -alto/2, -grosor/2,
      ancho/2, -alto/2, -grosor/2,
      ancho/2, alto/2, -grosor/2,
      -ancho/2, alto/2, -grosor/2,
      
      // Lado izquierdo (marco grueso)
      -ancho/2, -alto/2, grosor/2,
      -ancho/2, -alto/2, -grosor/2,
      -ancho/2, alto/2, -grosor/2,
      -ancho/2, alto/2, grosor/2,
      
      // Lado derecho (marco grueso)
      ancho/2, -alto/2, grosor/2,
      ancho/2, -alto/2, -grosor/2,
      ancho/2, alto/2, -grosor/2,
      ancho/2, alto/2, grosor/2,
      
      // Base inferior (con soporte)
      -ancho/3, -alto/2, grosor/2,
      ancho/3, -alto/2, grosor/2,
      ancho/3, -alto/2, -grosor*3,
      -ancho/3, -alto/2, -grosor*3,
      
      // Parte superior (marco delgado)
      -ancho/2, alto/2, grosor/2,
      ancho/2, alto/2, grosor/2,
      ancho/2, alto/2, -grosor/2,
      -ancho/2, alto/2, -grosor/2
    ];

    // Colores (pantalla gris, marco negro)
    var colores = [
      // Pantalla frontal (área de visualización gris, marco negro)
      0.9, 0.9, 0.9, 1,  // Centro pantalla
      0.9, 0.9, 0.9, 1,
      0.9, 0.9, 0.9, 1,
      0.9, 0.9, 0.9, 1,
      
      // Parte trasera (negro mate)
      0.1, 0.1, 0.1, 1,
      0.1, 0.1, 0.1, 1,
      0.1, 0.1, 0.1, 1,
      0.1, 0.1, 0.1, 1,
      
      // Lados (negro con detalle)
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1,
      
      // Lado derecho
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1,
      
      // Base (negro con acentos)
      0.15, 0.15, 0.15, 1,
      0.15, 0.15, 0.15, 1,
      0.15, 0.15, 0.15, 1,
      0.15, 0.15, 0.15, 1,
      
      // Parte superior (marco delgado)
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1,
      0.2, 0.2, 0.2, 1
    ];

    // Índices (6 caras x 2 triángulos x 3 vértices = 36 índices)
    var indices = [
      0, 1, 2, 0, 2, 3,    // Pantalla frontal
      4, 5, 6, 4, 6, 7,    // Parte trasera
      8, 9,10, 8,10,11,    // Lado izquierdo
     12,13,14,12,14,15,    // Lado derecho
     16,17,18,16,18,19,    // Base
     20,21,22,20,22,23     // Parte superior
    ];

    this.monitorVAO = gl.createVertexArray();
    gl.bindVertexArray(this.monitorVAO);

    // Configuración de buffers (igual que tu cubo original)
    var vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

    var colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

    var indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    gl.bindVertexArray(null);

    // Buffer de aristas (bordes del monitor)
    const aristas = [
      // Contorno frontal
      0,1, 1,2, 2,3, 3,0,
      // Contorno trasero
      4,5, 5,6, 6,7, 7,4,
      // Conectores laterales
      0,4, 1,5, 2,6, 3,7,
      // Base
      16,17, 17,18, 18,19, 19,16
    ];
    
    this.numAristas = aristas.length;
    this.aristasBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.aristasBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(aristas), gl.STATIC_DRAW);
    // ============ FIN DE AGREGADO ============ //
  }

  dibuja(gl) {
    gl.bindVertexArray(this.monitorVAO);
    
    if(modoLineas) {
      gl.drawElements(gl.LINES, this.numAristas, gl.UNSIGNED_SHORT, 0); // Usa aristas
    } else {
      gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0); // Modo normal
    }
    
    gl.bindVertexArray(null);
  }
}


    /***************************************************************************/
    /* Eventos del Ratón                                                       */
    /***************************************************************************/

    function getMousePos(canvas, evt) {
      let rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    }

    function mouseDown(event) {
      let pos = getMousePos(canvas, event);
      B = MatrizRotacion.slice();
      arcBall.primerPunto(pos.x, pos.y);
      boton_izq_presionado = true;
      return false;
    }

    function mouseUp() {
      boton_izq_presionado = false;
    }

    function mouseMove(event) {
      if (!boton_izq_presionado) return;
      
      let pos = getMousePos(canvas, event);
      let q = arcBall.segundoPunto(pos.x, pos.y);
      Cuaternion.rota2(MatrizRotacion, q);
      multiplica(MatrizRotacion, MatrizRotacion, B);
    }

    /***************************************************************************/
    /* Renderizado                                                             */
    /***************************************************************************/

    function dibuja() {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  updateInfoPanel();

  // Configurar proyección según selección
  if (document.getElementById('opcion1').checked) {
    perspective(MatrizProyeccion, 60, ancho/alto, 2, 100);
  } else if (document.getElementById('opcion2').checked) {
    frustum(MatrizProyeccion, -1.15*ancho/alto, 1.15*ancho/alto, -1.15, 1.15, 2, 100);
  } else {
    ortho(MatrizProyeccion, -10*ancho/alto, 10*ancho/alto, -10, 10, 2, 100);
  }
  gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

  // Dibujar ejes si están activos
  if (showAxes) {
    identidad(MatrizModelo);
    gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
    ejes.dibuja(gl);
  }

  // Transformación base del piso (incluye la rotación global)
  identidad(MatrizModelo);
  traslacion(MatrizModelo, 0, -1.5, zoom);  // Usamos la variable zoom aquí
  escalacion(MatrizModelo, 0.5, 0.5, 0.5);
  multiplica(MatrizModelo, MatrizModelo, MatrizRotacion);

  
  
  // Guardamos la matriz de transformación del piso
  let matrizPiso = MatrizModelo.slice();
  
  // Dibujar piso
  gl.uniformMatrix4fv(uMatrizModelo, false, matrizPiso);
  piso.dibuja(gl);

  gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
  monitor.dibuja(gl);

  // Posiciones de los cubos relativas al piso
  const cuboPositions = [
    { x: -2, y: 0.5, z: -2, rotY: 0, scale: 0.3 },
    { x: 2, y: 0.5, z: -2, rotY: 45, scale: 0.3 },
    { x: 2, y: 0.5, z: 2, rotY: 90, scale: 0.3 },
    { x: -2, y: 0.5, z: 2, rotY: 135, scale: 0.3 },
    { x: 0, y: 1.0, z: 0, rotY: 180, scale: 0.4 }  // Cubo central elevado
  ];

  // Dibujar cubos como "hijos" del piso
  cuboPositions.forEach(pos => {
    // Comenzamos con la matriz de transformación del piso
    MatrizModelo = matrizPiso.slice();
    
    // Aplicamos transformaciones locales del cubo
    traslacion(MatrizModelo, pos.x, pos.y, pos.z); // Posición relativa al piso
    rotacionY(MatrizModelo, pos.rotY);            // Rotación local del cubo
    escalacion(MatrizModelo, pos.scale, pos.scale, pos.scale); // Escala local
    
    gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
    cubo.dibuja(gl);
  });

  requestAnimationFrame(dibuja);
}

    function updateInfoPanel() {
      // Ocultar todos los paneles primero
      document.querySelectorAll('.proj-info').forEach(el => {
        el.style.display = 'none';
      });
      
      // Mostrar el panel correspondiente a la selección
      if (document.getElementById('opcion1').checked) {
        document.getElementById('perspectiva-info').style.display = 'block';
      } else if (document.getElementById('opcion2').checked) {
        document.getElementById('frustum-info').style.display = 'block';
      } else {
        document.getElementById('ortografica-info').style.display = 'block';
      }
    }

    function handleMouseWheel(event) {
      event.preventDefault();
        
      // Ajustar el zoom basado en la dirección del scroll
      zoom += event.deltaY * -0.01 * zoomSensitivity;
        
      // Limitar el rango del zoom (opcional)
      zoom = Math.max(-30, Math.min(-5, zoom)); // Entre -30 (lejos) y -5 (cerca)
    }

        function reinicia() {
          /* Matriz de Rotación */
          identidad(MatrizRotacion);
          dibuja();
        }

        /***************************************************************************/
        /* Se prepara el lienzo y se obtiene el contexto del WebGL.                */
        /***************************************************************************/
        function main() {
          canvas = document.getElementById("webglcanvas");
          gl = canvas.getContext("webgl2");
          if (!gl) {
             document.write("WebGL 2.0 no está disponible en tu navegador");
             return;
          }
          canvas.addEventListener("mousedown", mouseDown, false);
          canvas.addEventListener("mouseup", mouseUp, false);
          canvas.addEventListener("mouseout", mouseUp, false);
          canvas.addEventListener("mousemove", mouseMove, false);
          document.getElementById("reset").onclick = reinicia;
          document.getElementById("opciones").onchange = dibuja;
          canvas.addEventListener("wheel", handleMouseWheel, false);
          document.getElementById("toggleAxes").onclick = function() {
            showAxes = !showAxes;
          };
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          compilaEnlazaLosShaders();

          /* Objetos */
          cubo = new Cubo(gl);
          piso = new Piso(gl,0,0,0);
          ejes = new Ejes(gl);
          monitor = new MonitorPlano(gl);
          arcBall = new ArcBall(ancho, alto);
          

          gl.useProgram(programaID);
          uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
          uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
          uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
          ortho(MatrizProyeccion, -5, 5, -5, 5, -5, 5);
          gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
          lookAt(MatrizVista, 0, 0, 0, 0, 0, -1, 0, 1, 0);
          gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
          identidad(MatrizRotacion);
          arcBall.ajusta(gl.canvas.width, gl.canvas.height);
          gl.enable(gl.DEPTH_TEST);
          gl.clearColor(176/255, 196/255, 222/256, 1);
          dibuja();
        }

        /* Llama a main una vez que la página web se haya cargado. */
        window.onload = main;

      </script>
   </body>
</html>